//CHECKSUM:b9911b1f4ae4e1265a141ca573a246c36e7859eecb3d8875b5077ee19807d7c1
{"version":3,"sources":["../actions/appendContext.js"],"names":["_","require","appendContext","contexts","ttl","existing","event","state","session","nluContexts","add","trim","split","merged","map","x","context","isNaN","Number","final","visited","ctx","push","chain","filter","orderBy","first","value","args"],"mappings":";;AAAA,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;AAEA;;;;;;;;;;;;;;;;;;;;;;AAoBA,MAAMC,aAAa,GAAG,CAACC,QAAD,EAAWC,GAAX,KAAmB;AACvC,QAAMC,QAAQ,GAAGC,KAAK,CAACC,KAAN,CAAYC,OAAZ,CAAoBC,WAApB,IAAmC,EAApD;AACA,QAAMC,GAAG,GAAGP,QAAQ,CAACQ,IAAT,GAAgBC,KAAhB,CAAsB,GAAtB,CAAZ;AACA,QAAMC,MAAM,GAAG,CACb,GAAGR,QADU,EAEb,GAAGK,GAAG,CAACI,GAAJ,CAAQC,CAAC,KAAK;AACfC,IAAAA,OAAO,EAAED,CADM;AAEfX,IAAAA,GAAG,EAAEa,KAAK,CAACC,MAAM,CAACd,GAAD,CAAP,CAAL,GAAqB,IAArB,GAA4Bc,MAAM,CAACd,GAAD;AAFxB,GAAL,CAAT,CAFU,CAAf;AAQA,QAAMe,KAAK,GAAG,EAAd;AACA,QAAMC,OAAO,GAAG,EAAhB;;AACA,OAAK,MAAMC,GAAX,IAAkBR,MAAlB,EAA0B;AACxB,QAAIO,OAAO,CAACC,GAAG,CAACL,OAAL,CAAX,EAA0B;AACxB;AACD;;AACDG,IAAAA,KAAK,CAACG,IAAN,CACEtB,CAAC,CAACuB,KAAF,CAAQV,MAAR,EACGW,MADH,CACUT,CAAC,IAAIA,CAAC,CAACC,OAAF,KAAcK,GAAG,CAACL,OADjC,EAEGS,OAFH,CAEW,KAFX,EAEkB,MAFlB,EAGGC,KAHH,GAIGC,KAJH,EADF;AAOAP,IAAAA,OAAO,CAACC,GAAG,CAACL,OAAL,CAAP,GAAuB,IAAvB;AACD;;AAEDV,EAAAA,KAAK,CAACC,KAAN,CAAYC,OAAZ,CAAoBC,WAApB,GAAkCU,KAAlC;AACD,CA5BD;;AA8BA,OAAOjB,aAAa,CAAC0B,IAAI,CAACzB,QAAN,EAAgByB,IAAI,CAACxB,GAArB,CAApB","sourceRoot":"/var/lib/jenkins/workspace/build-linux/modules/builtin/src/backend","sourcesContent":["const _ = require('lodash')\n\n/**\n * Appends the provided context(s) to the list of contexts that will be used by the NLU Engine\n * for the next messages for that chat session.\n *\n * The TTL (Time-To-Live) represents how long the contexts will be valid before they are automatically removed.\n * For example, the default value of `1` will listen for that context only once (the next time the user speaks).\n *\n * If a context was already present in the list, the higher TTL will win.\n * To force override a specific context, use the `removeContext` action before this action.\n *\n * This method is contextual to the current user and chat session.\n *\n * You can specify more than one context by separating them with a comma.\n *\n * @title Append Context\n * @category NLU\n * @author Botpress, Inc.\n * @param {string} contexts - Comma-separated list of contexts\n * @param {string} [ttl=1] - Time-To-Live of the context in number of dialog turns. Put `0` to disable expiry.\n */\nconst appendContext = (contexts, ttl) => {\n  const existing = event.state.session.nluContexts || []\n  const add = contexts.trim().split(',')\n  const merged = [\n    ...existing,\n    ...add.map(x => ({\n      context: x,\n      ttl: isNaN(Number(ttl)) ? 1000 : Number(ttl)\n    }))\n  ]\n\n  const final = []\n  const visited = {}\n  for (const ctx of merged) {\n    if (visited[ctx.context]) {\n      continue\n    }\n    final.push(\n      _.chain(merged)\n        .filter(x => x.context === ctx.context)\n        .orderBy('ttl', 'desc')\n        .first()\n        .value()\n    )\n    visited[ctx.context] = true\n  }\n\n  event.state.session.nluContexts = final\n}\n\nreturn appendContext(args.contexts, args.ttl)\n"]}